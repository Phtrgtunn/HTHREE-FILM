class l{constructor(a={}){this.cache=new Map,this.defaultTTL=a.defaultTTL||5*60*1e3,this.maxSize=a.maxSize||100}generateKey(a,t={}){const e=Object.keys(t).sort().map(s=>`${s}=${JSON.stringify(t[s])}`).join("&");return`${a}?${e}`}get(a){const t=this.cache.get(a);if(!t)return null;const s=Date.now()-t.timestamp;return{data:t.data,age:s,isStale:s>t.ttl,isFresh:s<=t.ttl}}set(a,t,e=this.defaultTTL){if(this.cache.size>=this.maxSize){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(a,{data:t,timestamp:Date.now(),ttl:e})}delete(a){this.cache.delete(a)}clear(){this.cache.clear()}clearExpired(){const a=Date.now();for(const[t,e]of this.cache.entries())a-e.timestamp>e.ttl*2&&this.cache.delete(t)}getStats(){return{size:this.cache.size,maxSize:this.maxSize,keys:Array.from(this.cache.keys())}}}const r=new l({defaultTTL:5*60*1e3,maxSize:100}),i={async get(c,a,t=5*60*1e3){const e=r.get(c);if(e&&e.isFresh)return console.log(`âœ… Cache HIT (fresh): ${c}`),e.data;if(e&&e.isStale){console.log(`âš ï¸ Cache HIT (stale): ${c} - Revalidating...`);const s=e.data;return a().then(o=>{r.set(c,o,t),console.log(`âœ… Cache UPDATED: ${c}`)}).catch(o=>{console.error(`âŒ Cache revalidation failed: ${c}`,o)}),s}console.log(`âŒ Cache MISS: ${c}`);try{const s=await a();return r.set(c,s,t),s}catch(s){if(e)return console.warn(`âš ï¸ Fetch failed, returning stale data: ${c}`),e.data;throw s}},invalidate(c){const t=r.getStats().keys.filter(e=>e.includes(c));t.forEach(e=>{r.delete(e)}),console.log(`ðŸ—‘ï¸ Invalidated ${t.length} cache entries matching: ${c}`)},clear(){r.clear(),console.log("ðŸ—‘ï¸ All cache cleared")},getStats(){return r.getStats()}};setInterval(()=>{r.clearExpired(),console.log("ðŸ§¹ Cleared expired cache")},10*60*1e3);const n=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));export{i as a,n as u};
